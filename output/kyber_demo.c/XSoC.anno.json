[
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/MulAddRecFN_e8_s24:MulAddRecFN_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.2807017543859649
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundRawFNToRecFN_e8_s24",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/MulAddRecFN_e8_s24:MulAddRecFN_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.2982456140350877
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_1",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/AddRecFN:AddRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.3508771929824561
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundRawFNToRecFN_e8_s24_1",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/AddRecFN:AddRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.3684210526315789
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_2",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/MulRecFN:MulRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.43859649122807015
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundRawFNToRecFN_e8_s24_2",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/MulRecFN:MulRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.45614035087719296
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_3",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/DivSqrtRecFM_small_e8_s24:DivSqrtRecFM_small_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.5263157894736842
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|RoundRawFNToRecFN_e8_s24_3",
    "duplicate":"~XSoC|XSoC/core:Top/core:Core/Execute:Execute/FPU:FPU/DivSqrtRecFM_small_e8_s24:DivSqrtRecFM_small_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.543859649122807
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|WishboneHost",
    "duplicate":"~XSoC|XSoC/hostAdapter:WishboneHost",
    "index":0.8421052631578947
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|WishboneDevice",
    "duplicate":"~XSoC|XSoC/deviceAdapter:WishboneDevice",
    "index":0.8596491228070176
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|WishboneHost_1",
    "duplicate":"~XSoC|XSoC/uartHostAdapter:WishboneHost",
    "index":0.9649122807017544
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~XSoC|WishboneDevice_1",
    "duplicate":"~XSoC|XSoC/uartDeviceAdapter:WishboneDevice",
    "index":0.9824561403508771
  },
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/uartDeviceAdapter:WishboneDevice>io_wbSlaveTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/uartDeviceAdapter:WishboneDevice>io_wbMasterReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/uartHostAdapter:WishboneHost>io_wbSlaveReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/uartHostAdapter:WishboneHost>io_wbMasterTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|BabyKyberTop>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"MatrixTranspose.sv",
    "text":"module MatrixTranspose #(\n) (\n    \n    input  logic signed [31:0] matrix_in [3:0][3:0], \n    output logic signed [31:0] matrix_out [3:0][3:0] \n);\n    always_comb begin\n        matrix_out[0] = matrix_in[0];\n        matrix_out[1] = matrix_in[2];\n        matrix_out[2] = matrix_in[1];\n        matrix_out[3] = matrix_in[3];\n    end\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"PolynomialMatrixMultiplication.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule PolynomialMatrixMultiplication (\n    input logic clk,\n    input logic rst_n,\n    input logic enable,\n    input logic signed [31:0] polynomial1 [3:0], \n    input logic signed [31:0] polynomial2 [3:0], \n    \n    output logic signed [31:0] polynomial_out [3:0] \n);\n    logic signed [31:0] temp_result [3:0];\n\n    always_comb begin\n        for (int k = 0; k < 4; k++) begin\n            temp_result[k] = 0;\n    \n        end\n\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < (4 - i); j++) begin\n                temp_result[i+j] = temp_result[i+j] + (polynomial1[i] * polynomial2[j]);\n            end\n        end\n\n        for (int a = 1; a < 4; a++) begin\n            for (int b = 4 - a; b < 4; b++) begin\n                temp_result[b + a - 4] = temp_result[b + a - 4] - (polynomial1[b] * polynomial2[a]);\n            end\n        end\n\n        for (int k = 0; k < 4; k++) begin\n    if (temp_result[k] < 0) begin\n        temp_result[k] = (temp_result[k] % 17 + 17) % 17;\n    end else begin\n        temp_result[k] = temp_result[k] % 17;\n    end\n    // $display(temp_result[k]);\nend\n\n\n    end\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            polynomial_out[0] <= 0;\n            polynomial_out[1] <= 0;\n            polynomial_out[2] <= 0;\n            polynomial_out[3] <= 0;\n        end else if (enable) begin\n            polynomial_out[0] <= temp_result[0];\n            polynomial_out[1] <= temp_result[1];\n            polynomial_out[2] <= temp_result[2];\n            polynomial_out[3] <= temp_result[3];\n            \n        end\n    end\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"KeyGeneration.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule KeyGeneration (\n   \n    input logic signed [31:0] A [3:0][3:0],\n    input logic signed[31:0] e [1:0][3:0],\n    input logic signed [31:0] secret_key [1:0][3:0],\n    output logic signed [31:0] secretkey [1:0][3:0],\n    output logic signed [31:0] result [1:0][3:0],\n    output logic signed [31:0] combined_output [1:0][3:0][3:0],\n    input logic clk,\n    input logic rst_n,\n    input logic key_enable,\n    output logic key_done\n);\n   \n    logic signed[31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] poly_out2 [3:0];\n    logic signed [31:0] poly_out3 [3:0];\n    logic signed [31:0] added [3:0];\n    logic signed [31:0] added1 [3:0];\n    logic key_done_next; // Intermediate signal for delaying key_done\n\n    // Secret key assignment\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            for (int i = 0; i < 2; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    secretkey[i][j] <= 0;\n                end\n            end\n        end else if (key_enable) begin\n            secretkey[0][0] <= secret_key[0][0];\n            secretkey[0][1] <= secret_key[0][1];\n            secretkey[0][2] <= secret_key[0][2];\n            secretkey[0][3] <= secret_key[0][3];\n            secretkey[1][0] <= secret_key[1][0];\n            secretkey[1][1] <= secret_key[1][1];\n            secretkey[1][2] <= secret_key[1][2];\n            secretkey[1][3] <= secret_key[1][3];\n        end\n    end\n\n    // Polynomial matrix multiplications\n    PolynomialMatrixMultiplication poly_mult0 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[0]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out0)\n    );\n    \n    PolynomialMatrixMultiplication poly_mult1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[1]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    PolynomialMatrixMultiplication poly_mult2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[2]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out2)\n    );\n\n    PolynomialMatrixMultiplication poly_mult3 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[3]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out3)\n    );\n\n    // Combinational logic for result computation\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            added[i] = 0;\n            added1[i] = 0;\n            result[0][i] = 0;\n            result[1][i] = 0;\n        end\n        if (key_enable) begin\n            for (int i = 0; i < 4; i++) begin\n                added[i] = (poly_out0[i] + poly_out1[i]);\n                added1[i] = (poly_out2[i] + poly_out3[i]);\n                if (added[i] < 0) begin\n                    added[i] = added[i];\n                end else begin\n                    added[i] = (added[i] % 17);\n                end\n\n                if (added1[i] < 0) begin\n                    added1[i] = added1[i];\n                end else begin\n                    added1[i] = (added1[i] % 17);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                result[0][i] = added[i] + e[0][i];\n                result[1][i] = added1[i] + e[1][i];\n                if (result[0][i] < 0) begin\n                    result[0][i] = result[0][i];\n                end else begin\n                    result[0][i] = (result[0][i] % 17);\n                end\n                if (result[1][i] < 0) begin\n                    result[1][i] = result[1][i];\n                end else begin\n                    result[1][i] = (result[1][i] % 17);\n                end\n            end\n        end\n    end\n\n    // Sequential logic for combined_output and key_done\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            for (int i = 0; i < 2; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    for (int k = 0; k < 4; k++) begin\n                        combined_output[i][j][k] <= 0;\n                    end\n                end\n            end\n            key_done <= 0;\n            key_done_next <= 0;\n        end else begin\n            if (key_enable) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        combined_output[0][i][j] <= A[i][j];\n                    end\n                end\n                for (int i = 0; i < 2; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        combined_output[1][i][j] <= result[i][j];\n                    end\n                end\n                key_done_next <= 1; // Set intermediate signal\n            end else begin\n                key_done_next <= 0;\n            end\n            key_done <= key_done_next; // Delay key_done by one cycle\n        end\n    end\n\nendmodule"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"Encrypt.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule Encrypt (\n    input logic clk,\n    input logic rst_n,\n    input logic encryption_enable,\n    input logic [31:0] message,\n    input logic signed [31:0] r [1:0][3:0],\n    input logic signed [31:0] e1 [1:0][3:0],\n    input logic signed [31:0] e2 [3:0],\n    input logic signed [31:0] combined_output [1:0][3:0][3:0],\n    output logic signed [31:0] ciphertext[1:0] [1:0][3:0],\n    output logic encryption_done\n);\n\n    logic signed [31:0] transposed_matrix [3:0][3:0];\n    logic signed [31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] poly_out2 [3:0];\n    logic signed [31:0] poly_out3 [3:0];\n    logic signed [31:0] poly_out4 [3:0];\n    logic signed [31:0] poly_out5 [3:0];\n    logic signed [31:0] added [3:0];\n    logic signed [31:0] added1 [3:0];\n    logic signed [31:0] added2 [3:0];\n    logic signed [3:0] coefficients;\n    logic signed [31:0] coefficients_scaled [3:0];\n    logic signed [31:0] u [1:0][3:0];\n    logic signed [31:0] v [3:0];\n    logic signed [31:0] temp [3:0];\n\n    MatrixTranspose transpose_inst (\n        .matrix_in(combined_output[0]),\n        .matrix_out(transposed_matrix)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[0]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out0)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[1]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[2]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out2)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst3 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[3]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out3)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst4 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(combined_output[1][0]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out4)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst5 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(combined_output[1][1]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out5)\n    );\n\n    always_ff @(posedge clk ) begin\n        if (!rst_n) begin\n                for (int j = 0; j < 4; j++) begin\n                    coefficients[j] <= 0;\n\n                end\n            \n        end else if (encryption_enable) begin\n            \n            for (int i = 0; i < 4; i++) begin\n                    coefficients[i] <= message[i];\n\n                end\n\n           encryption_done<=1;\n        end\n    end\n\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            added[i] = 0;\n            added1[i] = 0;\n            added2[i] = 0;\n            u[0][i] = 0;\n            u[1][i] = 0;\n        end\n        if (encryption_enable) begin\n            \n            for (int i = 0; i < 4; i++) begin\n                \n                added[i] = (poly_out0[i] + poly_out1[i]);\n                added1[i] = (poly_out2[i] + poly_out3[i]);\n                added2[i] = (poly_out4[i] + poly_out5[i]); \n\n                if (added[i] < 0) begin\n                    added[i] = added[i]; \n                end else begin\n                    added[i] = (added[i] % 17);\n                end\n\n                if (added1[i] < 0) begin\n                    added1[i] = added1[i] ;\n                end else begin\n                    added1[i] = (added1[i] % 17);\n                end\n\n                if (added2[i] < 0) begin\n                    added2[i] = added2[i];\n                end else begin\n                    added2[i] = (added2[i] % 17);\n                end\n               \n            end\n           \n            for (int i = 0; i < 4; i++) begin\n                u[0][i] = added[i] + e1[0][i];\n                u[1][i] = added1[i] + e1[1][i];\n                 if ( u[0][i]  < 0) begin\n                     u[0][i]  = u[0][i] ;\n                end else begin\n                     u[0][i]  = ( u[0][i]  % 17);\n                end\n                if ( u[1][i]  < 0) begin\n                     u[1][i]  = u[1][i] ;\n                end else begin\n                     u[1][i]  = ( u[1][i]  % 17);\n\n                \n            end\n        end\n    end\n    end\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            if (coefficients[i] == 1) begin\n                coefficients_scaled[i] = 9;  // Multiply by qhalf = 9\n            end else begin\n                coefficients_scaled[i] = 0;  \n            end\n        end\n    end\n\n    always_comb begin\n\n        for (int i = 0; i < 4; i++) begin\n            \n            v[i] = (added2[i] + e2[i]) - coefficients_scaled[3-i];\n             if ( v[i] < 0) begin\n                     v[i] = v[i] + 17;\n                end else begin\n                     v[i] = ( v[i] % 17);\n                end\n            \n        end\n        for (int i = 0; i < 2; i++) begin\n            \n            for (int j = 0; j < 4; j++) begin\n                ciphertext[0][i][j] = u[i][j];\n                ciphertext[1][0][j] = v[j];\n            end\n            \n        end\n                \n\n    end\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"Decrypt.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule Decrypt (\n    input logic clk,\n    input logic rst_n,\n    input logic decryption_enable,\n    input logic signed [31:0] secret_key [1:0][3:0],\n    input logic signed [31:0] ciphertext[1:0][1:0][3:0],\n    output logic signed [3:0] m_b, \n    output logic decryption_done,\n    output logic [31:0] decimal_value    \n);\n    parameter int Q = 17; \n    logic signed [31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] temp_m_n [3:0];\n    logic decryption_done_next; // Intermediate signal for delaying decryption_done\n\n    PolynomialMatrixMultiplication poly_mult1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(decryption_enable),\n        .polynomial1(ciphertext[0][0]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out0)\n    );\n\n    PolynomialMatrixMultiplication poly_mult2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(decryption_enable),\n        .polynomial1(ciphertext[0][1]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            temp_m_n[i] = ciphertext[1][0][i] - (poly_out0[i] + poly_out1[i]);\n\n            if (temp_m_n[i] < 0) begin\n                temp_m_n[i] += Q;\n                if (temp_m_n[i] < 0) begin\n                    temp_m_n[i] += Q;\n                end\n            end else begin\n                temp_m_n[i] = temp_m_n[i] % Q;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            if (temp_m_n[i] < 5) begin\n                temp_m_n[i] = 0;\n            end else if (temp_m_n[i] < 14) begin\n                temp_m_n[i] = 9;\n            end else begin\n                temp_m_n[i] = 0;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            m_b[i] = (temp_m_n[i] == 9) ? 1 : 0;\n        end\n        \n        decimal_value = (m_b[0] ? 8 : 0) | (m_b[1] ? 4 : 0) | (m_b[2] ? 2 : 0) | (m_b[3] ? 1 : 0);\n        $display(\"decimal_value = %0d\", decimal_value);\n    end\n\n    // Sequential logic for decryption_done\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            decryption_done <= 0;\n            decryption_done_next <= 0;\n        end else begin\n            decryption_done_next <= decryption_enable; // Set when decryption_enable is active\n            decryption_done <= decryption_done_next; // Delay by one cycle\n        end\n    end\n\nendmodule"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.kybertop",
    "name":"kybertop.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project. */\n\nmodule kybertop (\n    input logic clk,\n    input logic rst_n,\n    input logic enable,\n    input logic key_enable,\n    input logic encryption_enable,\n    input logic decryption_enable,\n    input logic signed [31:0] data_Req,\n    input logic signed [31:0] addr_Req,\n    input logic wen_Req,\n    output logic key_done,\n    output logic encryption_done,\n    output logic decryption_done,\n    input logic [7:0] bytelane_Req,\n    output logic signed [31:0] data_Resp\n);\n\nlogic signed [31:0] secretkey [1:0][3:0];\nlogic signed [31:0] result [1:0][3:0];\nlogic signed [31:0] public_key [1:0][3:0][3:0];\nlogic signed [31:0] A_reg [3:0][3:0];\nlogic signed [31:0] s_reg [1:0][3:0];\nlogic signed [31:0] e_reg [1:0][3:0];\nlogic signed [31:0] ciphertext[1:0][1:0][3:0];\nlogic signed [31:0] r [1:0][3:0];\nlogic signed [31:0] e1 [1:0][3:0];\nlogic signed [31:0] e2 [3:0];\nlogic signed [31:0] decimal_value;\nlogic signed [3:0] m_b;\nlogic signed [31:0] message;\n\n// Key Generation Input Registers\nlogic signed [31:0] A_t000, A_t001, A_t002, A_t003;\nlogic signed [31:0] A_t010, A_t011, A_t012, A_t013;\nlogic signed [31:0] A_t020, A_t021, A_t022, A_t023;\nlogic signed [31:0] A_t030, A_t031, A_t032, A_t033;\n\nlogic signed [31:0] s_00, s_01, s_02, s_03;\nlogic signed [31:0] s_10, s_11, s_12, s_13;\n\nlogic signed [31:0] e_00, e_01, e_02, e_03;\nlogic signed [31:0] e_10, e_11, e_12, e_13;\n\n// Encrypt Input Registers\nlogic signed [31:0] r_00, r_01, r_02, r_03;\nlogic signed [31:0] r_10, r_11, r_12, r_13;\n\nlogic signed [31:0] e1_00, e1_01, e1_02, e1_03;\nlogic signed [31:0] e1_10, e1_11, e1_12, e1_13;\n\nlogic signed [31:0] e2_0, e2_1, e2_2, e2_3;\n\n// Decryption Input Registers\nlogic signed [31:0] ciphertext000, ciphertext001, ciphertext002, ciphertext003;\nlogic signed [31:0] ciphertext010, ciphertext011, ciphertext012, ciphertext013;\nlogic signed [31:0] ciphertext100, ciphertext101, ciphertext102, ciphertext103;\n\nKeyGeneration keygen (\n    .clk(clk),\n    .rst_n(rst_n),\n    .key_enable(key_enable),\n    .A(A_reg),\n    .secret_key(s_reg),\n    .e(e_reg),\n    .secretkey(secretkey),\n    .result(result),\n    .combined_output(public_key),\n    .key_done(key_done) // Updated to key_done\n);\n\nEncrypt encryption (\n    .clk(clk),\n    .rst_n(rst_n),\n    .encryption_enable(encryption_enable),\n    .message(message),\n    .combined_output(public_key),\n    .r(r),\n    .e1(e1),\n    .e2(e2),\n    .ciphertext(ciphertext),\n    .encryption_done(encryption_done) // Updated to encryption_done\n);\n\nDecrypt decryption (\n    .clk(clk),\n    .rst_n(rst_n),\n    .decryption_enable(decryption_enable),\n    .ciphertext(ciphertext),\n    .secret_key(secretkey),\n    .m_b(m_b),\n    .decimal_value(decimal_value),\n    .decryption_done(decryption_done) // Updated to decrypt_done\n);\n\nalways_ff @(posedge clk) begin\n    if (!rst_n) begin\n        // Reset only internal/input registers\n        for (int i = 0; i < 2; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                s_reg[i][j] <= 32'b0;\n                e_reg[i][j] <= 32'b0;\n                r[i][j] <= 32'b0;\n                e1[i][j] <= 32'b0;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                A_reg[i][j] <= 32'b0;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            e2[i] <= 32'b0;\n        end\n\n        data_Resp <= 32'b0;\n        message <= 32'b0;\n\n        // Reset temporary registers\n        A_t000 <= 32'b0; A_t001 <= 32'b0; A_t002 <= 32'b0; A_t003 <= 32'b0;\n        A_t010 <= 32'b0; A_t011 <= 32'b0; A_t012 <= 32'b0; A_t013 <= 32'b0;\n        A_t020 <= 32'b0; A_t021 <= 32'b0; A_t022 <= 32'b0; A_t023 <= 32'b0;\n        A_t030 <= 32'b0; A_t031 <= 32'b0; A_t032 <= 32'b0; A_t033 <= 32'b0;\n\n        s_00 <= 32'b0; s_01 <= 32'b0; s_02 <= 32'b0; s_03 <= 32'b0;\n        s_10 <= 32'b0; s_11 <= 32'b0; s_12 <= 32'b0; s_13 <= 32'b0;\n\n        e_00 <= 32'b0; e_01 <= 32'b0; e_02 <= 32'b0; e_03 <= 32'b0;\n        e_10 <= 32'b0; e_11 <= 32'b0; e_12 <= 32'b0; e_13 <= 32'b0;\n\n        r_00 <= 32'b0; r_01 <= 32'b0; r_02 <= 32'b0; r_03 <= 32'b0;\n        r_10 <= 32'b0; r_11 <= 32'b0; r_12 <= 32'b0; r_13 <= 32'b0;\n\n        e1_00 <= 32'b0; e1_01 <= 32'b0; e1_02 <= 32'b0; e1_03 <= 32'b0;\n        e1_10 <= 32'b0; e1_11 <= 32'b0; e1_12 <= 32'b0; e1_13 <= 32'b0;\n\n        e2_0 <= 32'b0; e2_1 <= 32'b0; e2_2 <= 32'b0; e2_3 <= 32'b0;\n\n        ciphertext000 <= 32'b0; ciphertext001 <= 32'b0; ciphertext002 <= 32'b0; ciphertext003 <= 32'b0;\n        ciphertext010 <= 32'b0; ciphertext011 <= 32'b0; ciphertext012 <= 32'b0; ciphertext013 <= 32'b0;\n        ciphertext100 <= 32'b0; ciphertext101 <= 32'b0; ciphertext102 <= 32'b0; ciphertext103 <= 32'b0;\n\n    end else if (wen_Req && enable) begin\n      //  data_Resp <= 1;\n        $display(\"checking\");\n        if (enable) begin\n            if (addr_Req == 'h40007000) begin\n                A_t000 <= data_Req;\n            end else if (addr_Req == 'h40007004) begin\n                A_t001 <= data_Req;\n            end else if (addr_Req == 'h40007008) begin\n                A_t002 <= data_Req;\n            end else if (addr_Req == 'h4000700C) begin\n                A_t003 <= data_Req;\n            end else if (addr_Req == 'h40007010) begin\n                A_t010 <= data_Req;\n            end else if (addr_Req == 'h40007014) begin\n                A_t011 <= data_Req;\n            end else if (addr_Req == 'h40007018) begin\n                A_t012 <= data_Req;\n            end else if (addr_Req == 'h4000701C) begin\n                A_t013 <= data_Req;\n            end else if (addr_Req == 'h40007020) begin\n                A_t020 <= data_Req;\n            end else if (addr_Req == 'h40007024) begin\n                A_t021 <= data_Req;\n            end else if (addr_Req == 'h40007028) begin\n                A_t022 <= data_Req;\n            end else if (addr_Req == 'h4000702C) begin\n                A_t023 <= data_Req;\n            end else if (addr_Req == 'h40007030) begin\n                A_t030 <= data_Req;\n            end else if (addr_Req == 'h40007034) begin\n                A_t031 <= data_Req;\n            end else if (addr_Req == 'h40007038) begin\n                A_t032 <= data_Req;\n            end else if (addr_Req == 'h4000703C) begin\n                A_t033 <= data_Req;\n            end else if (addr_Req == 'h40007040) begin\n                s_00 <= data_Req;\n            end else if (addr_Req == 'h40007044) begin\n                s_01 <= data_Req;\n            end else if (addr_Req == 'h40007048) begin\n                s_02 <= data_Req;\n            end else if (addr_Req == 'h4000704C) begin\n                s_03 <= data_Req;\n            end else if (addr_Req == 'h40007050) begin\n                s_10 <= data_Req;\n            end else if (addr_Req == 'h40007054) begin\n                s_11 <= data_Req;\n            end else if (addr_Req == 'h40007058) begin\n                s_12 <= data_Req;\n            end else if (addr_Req == 'h4000705C) begin\n                s_13 <= data_Req;\n            end else if (addr_Req == 'h40007060) begin\n                e_00 <= data_Req;\n            end else if (addr_Req == 'h40007064) begin\n                e_01 <= data_Req;\n            end else if (addr_Req == 'h40007068) begin\n                e_02 <= data_Req;\n            end else if (addr_Req == 'h4000706C) begin\n                e_03 <= data_Req;\n            end else if (addr_Req == 'h40007070) begin\n                e_10 <= data_Req;\n            end else if (addr_Req == 'h40007074) begin\n                e_11 <= data_Req;\n            end else if (addr_Req == 'h40007078) begin\n                e_12 <= data_Req;\n            end else if (addr_Req == 'h4000707C) begin\n                e_13 <= data_Req;\n            end else if (addr_Req == 'h40007164) begin\n                // Key generation inputs\n                A_reg[0][0] <= A_t000;\n                A_reg[0][1] <= A_t001;\n                A_reg[0][2] <= A_t002;\n                A_reg[0][3] <= A_t003;\n                A_reg[1][0] <= A_t010;\n                A_reg[1][1] <= A_t011;\n                A_reg[1][2] <= A_t012;\n                A_reg[1][3] <= A_t013;\n                A_reg[2][0] <= A_t020;\n                A_reg[2][1] <= A_t021;\n                A_reg[2][2] <= A_t022;\n                A_reg[2][3] <= A_t023;\n                A_reg[3][0] <= A_t030;\n                A_reg[3][1] <= A_t031;\n                A_reg[3][2] <= A_t032;\n                A_reg[3][3] <= A_t033;\n\n                s_reg[0][0] <= s_00;\n                s_reg[0][1] <= s_01;\n                s_reg[0][2] <= s_02;\n                s_reg[0][3] <= s_03;\n                s_reg[1][0] <= s_10;\n                s_reg[1][1] <= s_11;\n                s_reg[1][2] <= s_12;\n                s_reg[1][3] <= s_13;\n\n                e_reg[0][0] <= e_00;\n                e_reg[0][1] <= e_01;\n                e_reg[0][2] <= e_02;\n                e_reg[0][3] <= e_03;\n                e_reg[1][0] <= e_10;\n                e_reg[1][1] <= e_11;\n                e_reg[1][2] <= e_12;\n                e_reg[1][3] <= e_13;\n            end\n        end\n        if (enable) begin\n            if (addr_Req == 'h40007080) begin\n                message <= data_Req;\n            end else if (addr_Req == 'h40007084) begin\n                r_00 <= data_Req;\n            end else if (addr_Req == 'h40007088) begin\n                r_01 <= data_Req;\n            end else if (addr_Req == 'h4000708C) begin\n                r_02 <= data_Req;\n            end else if (addr_Req == 'h40007090) begin\n                r_03 <= data_Req;\n            end else if (addr_Req == 'h40007094) begin\n                r_10 <= data_Req;\n            end else if (addr_Req == 'h40007098) begin\n                r_11 <= data_Req;\n            end else if (addr_Req == 'h4000709C) begin\n                r_12 <= data_Req;\n            end else if (addr_Req == 'h400070A0) begin\n                r_13 <= data_Req;\n            end else if (addr_Req == 'h400070A4) begin\n                e1_00 <= data_Req;\n            end else if (addr_Req == 'h400070A8) begin\n                e1_01 <= data_Req;\n            end else if (addr_Req == 'h400070AC) begin\n                e1_02 <= data_Req;\n            end else if (addr_Req == 'h400070B0) begin\n                e1_03 <= data_Req;\n            end else if (addr_Req == 'h400070B4) begin\n                e1_10 <= data_Req;\n            end else if (addr_Req == 'h400070B8) begin\n                e1_11 <= data_Req;\n            end else if (addr_Req == 'h400070BC) begin\n                e1_12 <= data_Req;\n            end else if (addr_Req == 'h400070C0) begin\n                e1_13 <= data_Req;\n            end else if (addr_Req == 'h400070C4) begin\n                e2_0 <= data_Req;\n            end else if (addr_Req == 'h400070C8) begin\n                e2_1 <= data_Req;\n            end else if (addr_Req == 'h400070CC) begin\n                e2_2 <= data_Req;\n            end else if (addr_Req == 'h400070D0) begin\n                e2_3 <= data_Req;\n            end else if (addr_Req == 'h40007168) begin\n                // Encrypt inputs\n                r[0][0] <= r_00;\n                r[0][1] <= r_01;\n                r[0][2] <= r_02;\n                r[0][3] <= r_03;\n                r[1][0] <= r_10;\n                r[1][1] <= r_11;\n                r[1][2] <= r_12;\n                r[1][3] <= r_13;\n\n                e1[0][0] <= e1_00;\n                e1[0][1] <= e1_01;\n                e1[0][2] <= e1_02;\n                e1[0][3] <= e1_03;\n                e1[1][0] <= e1_10;\n                e1[1][1] <= e1_11;\n                e1[1][2] <= e1_12;\n                e1[1][3] <= e1_13;\n\n                e2[0] <= e2_0;\n                e2[1] <= e2_1;\n                e2[2] <= e2_2;\n                e2[3] <= e2_3;\n\n                // Store Encrypt output in temporary registers\n                ciphertext000 <= ciphertext[0][0][0];\n                ciphertext001 <= ciphertext[0][0][1];\n                ciphertext002 <= ciphertext[0][0][2];\n                ciphertext003 <= ciphertext[0][0][3];\n                ciphertext010 <= ciphertext[0][1][0];\n                ciphertext011 <= ciphertext[0][1][1];\n                ciphertext012 <= ciphertext[0][1][2];\n                ciphertext013 <= ciphertext[0][1][3];\n                ciphertext100 <= ciphertext[1][0][0];\n                ciphertext101 <= ciphertext[1][0][1];\n                ciphertext102 <= ciphertext[1][0][2];\n                ciphertext103 <= ciphertext[1][0][3];\n            end\n        end\n        if (decryption_enable && addr_Req == 'h4000716C) begin\n            // No ciphertext assignments here; Decrypt uses ciphertext directly\n            // Decryption trigger (no action needed beyond enable_decrypt)\n        end\n    end else if (wen_Req == 1'b0) begin \n        case (addr_Req)\n            // Public Key (2x4x4 = 32 words) starting at 0x40007200\n            'h40007200: data_Resp <= public_key[0][0][0];\n            'h40007204: data_Resp <= public_key[0][0][1];\n            'h40007208: data_Resp <= public_key[0][0][2];\n            'h4000720C: data_Resp <= public_key[0][0][3];\n            'h40007210: data_Resp <= public_key[0][1][0];\n            'h40007214: data_Resp <= public_key[0][1][1];\n            'h40007218: data_Resp <= public_key[0][1][2];\n            'h4000721C: data_Resp <= public_key[0][1][3];\n            'h40007220: data_Resp <= public_key[0][2][0];\n            'h40007224: data_Resp <= public_key[0][2][1];\n            'h40007228: data_Resp <= public_key[0][2][2];\n            'h4000722C: data_Resp <= public_key[0][2][3];\n            'h40007230: data_Resp <= public_key[0][3][0];\n            'h40007234: data_Resp <= public_key[0][3][1];\n            'h40007238: data_Resp <= public_key[0][3][2];\n            'h4000723C: data_Resp <= public_key[0][3][3];\n            'h40007240: data_Resp <= public_key[1][0][0];\n            'h40007244: data_Resp <= public_key[1][0][1];\n            'h40007248: data_Resp <= public_key[1][0][2];\n            'h4000724C: data_Resp <= public_key[1][0][3];\n            'h40007250: data_Resp <= public_key[1][1][0];\n            'h40007254: data_Resp <= public_key[1][1][1];\n            'h40007258: data_Resp <= public_key[1][1][2];\n            'h4000725C: data_Resp <= public_key[1][1][3];\n            'h40007260: data_Resp <= public_key[1][2][0];\n            'h40007264: data_Resp <= public_key[1][2][1];\n            'h40007268: data_Resp <= public_key[1][2][2];\n            'h4000726C: data_Resp <= public_key[1][2][3];\n            'h40007270: data_Resp <= public_key[1][3][0];\n            'h40007274: data_Resp <= public_key[1][3][1];\n            'h40007278: data_Resp <= public_key[1][3][2];\n            'h4000727C: data_Resp <= public_key[1][3][3];\n\n            // Ciphertext (2x2x4 = 16 words) starting at 0x40007280\n            'h40007280: data_Resp <= ciphertext[0][0][0];\n            'h40007284: data_Resp <= ciphertext[0][0][1];\n            'h40007288: data_Resp <= ciphertext[0][0][2];\n            'h4000728C: data_Resp <= ciphertext[0][0][3];\n            'h40007290: data_Resp <= ciphertext[0][1][0];\n            'h40007294: data_Resp <= ciphertext[0][1][1];\n            'h40007298: data_Resp <= ciphertext[0][1][2];\n            'h4000729C: data_Resp <= ciphertext[0][1][3];\n            'h400072A0: data_Resp <= ciphertext[1][0][0];\n            'h400072A4: data_Resp <= ciphertext[1][0][1];\n            'h400072A8: data_Resp <= ciphertext[1][0][2];\n            'h400072AC: data_Resp <= ciphertext[1][0][3];\n            'h400072B0: data_Resp <= ciphertext[1][1][0];\n            'h400072B4: data_Resp <= ciphertext[1][1][1];\n            'h400072B8: data_Resp <= ciphertext[1][1][2];\n            'h400072BC: data_Resp <= ciphertext[1][1][3];\n\n            // Decrypted message, value, m_b\n            'h400072C0: data_Resp <= message;\n            'h400072C4: data_Resp <= decimal_value;\n            'h400072C8: data_Resp <= {{28{m_b[3]}}, m_b}; // Sign-extend m_b to 32 bits\n\n            default: data_Resp <= 32'b0;\n        endcase\n    end\nend\nendmodule"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/deviceAdapter:WishboneDevice>io_wbSlaveTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/deviceAdapter:WishboneDevice>io_wbMasterReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/hostAdapter:WishboneHost>io_wbSlaveReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|XSoC/hostAdapter:WishboneHost>io_wbMasterTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|SRamTop_1>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.sram_top_1",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n/* verilator lint_off WIDTH */\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 28,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.sram_top_1",
    "name":"sram_top.v",
    "text":"/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n/* verilator lint_off SYNCASYNCNET */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n// sram interface in\n  input   logic        csb_i,\n  input   logic [27:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n\n);\n\nlogic        csb;\nlogic [12:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(negedge clk_i) begin\n  if(rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  //.ADDR_WIDTH (13),\n  //.RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0) , // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n ) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n    .clk0(clk_i),\n    .csb0(csb_i),\n    .web0(we_i),\n    .wmask0(wmask_i),\n    .addr0(addr_i),\n    .din0(wdata_i),\n    .dout0(rdata_o),\n    .clk1('0),\n    .csb1('1),\n    .addr1('0),\n    .dout1()\n );\n\nalways_ff @(posedge clk_i or posedge rst_i) begin\n    if (rst_i) begin\n     rvalid <= 1'b0;\n    end else if (!we_i) begin\n     rvalid <= 1'b0;\n    end else if(!csb_i && we_i) begin\n     rvalid <= 1'b1;\n    end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|SRamTop_1>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|SRamTop>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.sram_top",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n/* verilator lint_off WIDTH */\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 28,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"XSoC.sram_top",
    "name":"sram_top.v",
    "text":"/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n/* verilator lint_off SYNCASYNCNET */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n// sram interface in\n  input   logic        csb_i,\n  input   logic [27:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n\n);\n\nlogic        csb;\nlogic [12:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(negedge clk_i) begin\n  if(rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  //.ADDR_WIDTH (13),\n  //.RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0) , // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n ) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n    .clk0(clk_i),\n    .csb0(csb_i),\n    .web0(we_i),\n    .wmask0(wmask_i),\n    .addr0(addr_i),\n    .din0(wdata_i),\n    .dout0(rdata_o),\n    .clk1('0),\n    .csb1('1),\n    .addr1('0),\n    .dout1()\n );\n\nalways_ff @(posedge clk_i or posedge rst_i) begin\n    if (rst_i) begin\n     rvalid <= 1'b0;\n    end else if (!we_i) begin\n     rvalid <= 1'b0;\n    end else if(!csb_i && we_i) begin\n     rvalid <= 1'b1;\n    end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|SRamTop>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>wb_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_bits_addrRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_bits_dataRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_bits_activeByteLane"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_req_bits_isWrite"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_rsp_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_rsp_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_rsp_bits_dataResponse"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_rsp_bits_error"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_cio_uart_rx_i"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_cio_uart_tx_o"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_uart_cio_uart_intr_tx_o"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_bits_addrRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_bits_dataRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_bits_activeByteLane"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_req_bits_isWrite"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_rsp_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_rsp_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_rsp_bits_dataResponse"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_rsp_bits_error"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_cio_babykyber_intr_key"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_cio_babykyber_intr_encrypt"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>io_baby_kyber_cio_babykyber_intr_decrypt"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>npc"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Core>is_comp"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Execute>f_multi_cycle_inst"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_in_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_in_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_in_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_aluOp"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_rm"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_div_sqrt_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_out"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_exceptions_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_exceptions_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_exceptions_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_exceptions_3"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_exceptions_4"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_div_sqrt_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|FPU>io_div_sqrt_valid_out"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Execute>f7_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|Execute>io_stall"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|InstructionDecode>writeData"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|InstructionDecode>registerRs1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|HazardUnit>io_pc_write"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_MISA_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_MHARTID_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_CSR_i_opr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_CSR_o_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_CSR_i_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_CSR_i_addr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_CSR_i_w_en"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_except_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_except_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_except_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_except_3"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_except_4"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_nx"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_uf"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_of"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_dz"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_nv"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|CSRRegFile>io_FCSR_frm"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|InstructionFetch>next_state"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|InstructionFetch>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~XSoC|InstructionFetch>io_stall"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"/home/mhussain/XSoC-Lite/output/kyber_demo.c"
  },
  {
    "class":"firrtl.transforms.CombinationalPath",
    "sink":"~XSoC|XSoC>io_rvfi_valid_0",
    "sources":[
      "~XSoC|XSoC>clock"
    ]
  }
]