[
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/MulAddRecFN_e8_s24:MulAddRecFN_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.40384615384615385
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundRawFNToRecFN_e8_s24",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/MulAddRecFN_e8_s24:MulAddRecFN_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.4230769230769231
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_1",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/AddRecFN:AddRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.4807692307692308
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundRawFNToRecFN_e8_s24_1",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/AddRecFN:AddRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.5
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_2",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/MulRecFN:MulRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.5769230769230769
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundRawFNToRecFN_e8_s24_2",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/MulRecFN:MulRecFN/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.5961538461538461
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundAnyRawFNToRecFN_ie8_is26_oe8_os24_3",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/DivSqrtRecFM_small_e8_s24:DivSqrtRecFM_small_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24/roundAnyRawFNToRecFN:RoundAnyRawFNToRecFN_ie8_is26_oe8_os24",
    "index":0.6730769230769231
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RoundRawFNToRecFN_e8_s24_3",
    "duplicate":"~Top|Top/core:Core/Execute:Execute/FPU:FPU/DivSqrtRecFM_small_e8_s24:DivSqrtRecFM_small_e8_s24/roundRawFNToRecFN:RoundRawFNToRecFN_e8_s24",
    "index":0.6923076923076923
  },
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop_1>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top_1",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n/* verilator lint_off WIDTH */\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 28,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top_1",
    "name":"sram_top.v",
    "text":"/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n/* verilator lint_off SYNCASYNCNET */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n// sram interface in\n  input   logic        csb_i,\n  input   logic [27:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n\n);\n\nlogic        csb;\nlogic [12:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(negedge clk_i) begin\n  if(rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  //.ADDR_WIDTH (13),\n  //.RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0) , // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n ) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n    .clk0(clk_i),\n    .csb0(csb_i),\n    .web0(we_i),\n    .wmask0(wmask_i),\n    .addr0(addr_i),\n    .din0(wdata_i),\n    .dout0(rdata_o),\n    .clk1('0),\n    .csb1('1),\n    .addr1('0),\n    .dout1()\n );\n\nalways_ff @(posedge clk_i or posedge rst_i) begin\n    if (rst_i) begin\n     rvalid <= 1'b0;\n    end else if (!we_i) begin\n     rvalid <= 1'b0;\n    end else if(!csb_i && we_i) begin\n     rvalid <= 1'b1;\n    end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop_1>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top",
    "name":"sram.v",
    "text":"// SPDX-FileCopyrightText: 2020 fabless Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// SPDX-License-Identifier: Apache-2.0\n\n//`default_nettype none\n// OpenRAM SRAM model\n// Words: 256\n// Word size: 32\n// Write size: 8\n\n/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off UNUSED */\n/* verilator lint_off BLKSEQ */\n/* verilator lint_off WIDTH */\nmodule sram #(\n  parameter NUM_WMASKS = 4,\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 28,\n  parameter RAM_DEPTH = 1 << ADDR_WIDTH,\n  // FIXME: This delay is arbitrary.\n  parameter DELAY = 3,\n  parameter IZERO   = 0 , // binary / Initial RAM with zeros (has priority over INITFILE)\n  parameter IFILE   = \"\"\n)\n(\n/*`ifdef USE_POWER_PINS\n\tvdd,\n\tgnd,\n`endif */\n// Port 0: RW\n    clk0,csb0,web0,wmask0,addr0,din0,dout0,\n// Port 1: R\n    clk1,csb1,addr1,dout1\n  );\n\n\n/*`ifdef USE_POWER_PINS\n  inout vdd;\n  inout gnd;\n`endif\n  */\n  input  clk0; // clock\n  input   csb0; // active low chip select\n  input  web0; // active low write control\n  input [NUM_WMASKS-1:0]   wmask0; // write mask\n  input [ADDR_WIDTH-1:0]  addr0;\n  input [DATA_WIDTH-1:0]  din0;\n  output [DATA_WIDTH-1:0] dout0;\n  input  clk1; // clock\n  input   csb1; // active low chip select\n  input [ADDR_WIDTH-1:0]  addr1;\n  output [DATA_WIDTH-1:0] dout1;\n\n  reg  csb0_reg;\n  reg  web0_reg;\n  reg [NUM_WMASKS-1:0]   wmask0_reg;\n  reg [ADDR_WIDTH-1:0]  addr0_reg;\n  reg [DATA_WIDTH-1:0]  din0_reg;\n  reg [DATA_WIDTH-1:0]  dout0;\n\n  // All inputs are registers\n  always @(posedge clk0)\n  begin\n    csb0_reg = csb0;\n    web0_reg = web0;\n    wmask0_reg = wmask0;\n    addr0_reg = addr0;\n    din0_reg = din0;\n    //dout0 = 32'bx0;\n/*`ifdef DBG\n    if ( !csb0_reg && web0_reg )\n      $display($time,\" Reading %m addr0=%b dout0=%b\",addr0_reg,mem[addr0_reg]);\n    if ( !csb0_reg && !web0_reg )\n      $display($time,\" Writing %m addr0=%b din0=%b wmask0=%b\",addr0_reg,din0_reg,wmask0_reg);\n`endif\n*/   end\n\n  reg  csb1_reg;\n  reg [ADDR_WIDTH-1:0]  addr1_reg;\n  reg [DATA_WIDTH-1:0]  dout1;\n\n  // All inputs are registers\n  always @(posedge clk1)\n  begin\n    csb1_reg = csb1;\n    addr1_reg = addr1;\n//`ifdef DBG\n//    if (!csb0 && !web0 && !csb1 && (addr0 == addr1))\n//         $display($time,\" WARNING: Writing and reading addr0=%b and addr1=%b simultaneously!\",addr0,addr1);\n//    dout1 = 32'bx;\n//    if ( !csb1_reg )\n//      $display($time,\" Reading %m addr1=%b dout1=%b\",addr1_reg,mem[addr1_reg]);\n//`endif\n   end\ninteger i;\nreg [DATA_WIDTH-1:0]    mem [0:RAM_DEPTH-1];\ninitial\n    if (IZERO)\n      for (i=0; i<RAM_DEPTH; i=i+1) mem[i] = {DATA_WIDTH{1'b0}};\n    else\n      if (IFILE != \"\") $readmemh(IFILE, mem);\n\n  // Memory Write Block Port 0\n  // Write Operation : When web0 = 0, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_WRITE0\n    if ( !csb0_reg && !web0_reg ) begin\n        if (wmask0_reg[0])\n                mem[addr0_reg][7:0] = din0_reg[7:0];\n        if (wmask0_reg[1])\n                mem[addr0_reg][15:8] = din0_reg[15:8];\n        if (wmask0_reg[2])\n                mem[addr0_reg][23:16] = din0_reg[23:16];\n        if (wmask0_reg[3])\n                mem[addr0_reg][31:24] = din0_reg[31:24];\n    end\n  end\n\n  // Memory Read Block Port 0\n  // Read Operation : When web0 = 1, csb0 = 0\n  always @ (negedge clk0)\n  begin : MEM_READ0\n    if (!csb0_reg && web0_reg)\n       dout0 <= #(DELAY) mem[addr0_reg];\n  end\n\n  // Memory Read Block Port 1\n  // Read Operation : When web1 = 1, csb1 = 0/\n always @ (negedge clk1)\n  begin : MEM_READ1\n   if (!csb1_reg)\n       dout1 <= #(DELAY) mem[addr1_reg];\n  end\n\nendmodule\n//`default_nettype wire\n\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.sram_top",
    "name":"sram_top.v",
    "text":"/* verilator lint_off ASSIGNDLY */\n/* verilator lint_off PINCONNECTEMPTY */\n/* verilator lint_off WIDTH */\n/* verilator lint_off UNUSED */\n/* verilator lint_off SYNCASYNCNET */\n\nmodule sram_top #(\n    parameter IFILE_IN = \"\"\n)\n(\n  input logic clk_i,\n  input logic rst_i,\n\n// sram interface in\n  input   logic        csb_i,\n  input   logic [27:0] addr_i,\n  input   logic [31:0] wdata_i,\n  input   logic [3:0]  wmask_i,\n  input   logic        we_i,\n  output  logic [31:0] rdata_o\n\n);\n\nlogic        csb;\nlogic [12:0] addr_o;\nlogic [31:0] wdata_o;\nlogic [3:0]  wmask_o;\nlogic        we_o;\nlogic [31:0] rdata_i;\n\nlogic rvalid;\n\nalways_ff @(negedge clk_i) begin\n  if(rst_i) begin\n    csb <= '1;\n    addr_o <= '0;\n    wdata_o <= '0;\n    wmask_o <= '0;\n    we_o <= '1;\n  end else begin\n    csb <= csb_i;\n    addr_o <= addr_i;\n    wdata_o <= wdata_i;\n    wmask_o <= wmask_i;\n    we_o <= we_i;\n  end\nend\n\nsram #(\n  .NUM_WMASKS (4),\n  .DATA_WIDTH (32),\n  //.ADDR_WIDTH (13),\n  //.RAM_DEPTH (1 << 13),\n  // FIXME: This delay is arbitrary.\n  .DELAY (3),\n  .IZERO (0) , // binary / Initial RAM with zeros (has priority over INITFILE)\n  .IFILE (IFILE_IN)\n ) memory (\n/*`ifdef USE_POWER_PINS\n\t.vdd,\n\t.gnd,\n`endif */\n    .clk0(clk_i),\n    .csb0(csb_i),\n    .web0(we_i),\n    .wmask0(wmask_i),\n    .addr0(addr_i),\n    .din0(wdata_i),\n    .dout0(rdata_o),\n    .clk1('0),\n    .csb1('1),\n    .addr1('0),\n    .dout1()\n );\n\nalways_ff @(posedge clk_i or posedge rst_i) begin\n    if (rst_i) begin\n     rvalid <= 1'b0;\n    end else if (!we_i) begin\n     rvalid <= 1'b0;\n    end else if(!csb_i && we_i) begin\n     rvalid <= 1'b1;\n    end\nend\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|SRamTop>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>wb_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_bits_addrRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_bits_dataRequest"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_bits_activeByteLane"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_req_bits_isWrite"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_rsp_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_rsp_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_rsp_bits_dataResponse"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_rsp_bits_error"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_cio_babykyber_intr_key"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_cio_babykyber_intr_encrypt"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>io_baby_kyber_cio_babykyber_intr_decrypt"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>npc"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Core>is_comp"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Execute>f_multi_cycle_inst"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_in_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_in_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_in_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_aluOp"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_rm"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_div_sqrt_valid"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_out"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_exceptions_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_exceptions_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_exceptions_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_exceptions_3"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_exceptions_4"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_div_sqrt_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|FPU>io_div_sqrt_valid_out"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Execute>f7_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|Execute>io_stall"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|InstructionDecode>writeData"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|InstructionDecode>registerRs1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|HazardUnit>io_pc_write"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_MISA_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_MHARTID_i_value"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_opr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_o_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_data"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_addr"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_CSR_i_w_en"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_except_0"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_except_1"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_except_2"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_except_3"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_except_4"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_nx"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_uf"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_of"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_dz"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_nv"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|CSRRegFile>io_FCSR_frm"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|InstructionFetch>next_state"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|InstructionFetch>state_reg"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|InstructionFetch>io_stall"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|BabyKyberTop>io_req_valid"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"MatrixTranspose.sv",
    "text":"module MatrixTranspose #(\n) (\n    \n    input  logic signed [31:0] matrix_in [3:0][3:0], \n    output logic signed [31:0] matrix_out [3:0][3:0] \n);\n    always_comb begin\n        matrix_out[0] = matrix_in[0];\n        matrix_out[1] = matrix_in[2];\n        matrix_out[2] = matrix_in[1];\n        matrix_out[3] = matrix_in[3];\n    end\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"PolynomialMatrixMultiplication.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule PolynomialMatrixMultiplication (\n    input logic clk,\n    input logic rst_n,\n    input logic enable,\n    input logic signed [31:0] polynomial1 [3:0], \n    input logic signed [31:0] polynomial2 [3:0], \n    \n    output logic signed [31:0] polynomial_out [3:0] \n);\n    logic signed [31:0] temp_result [3:0];\n\n    always_comb begin\n        for (int k = 0; k < 4; k++) begin\n            temp_result[k] = 0;\n    \n        end\n\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < (4 - i); j++) begin\n                temp_result[i+j] = temp_result[i+j] + (polynomial1[i] * polynomial2[j]);\n            end\n        end\n\n        for (int a = 1; a < 4; a++) begin\n            for (int b = 4 - a; b < 4; b++) begin\n                temp_result[b + a - 4] = temp_result[b + a - 4] - (polynomial1[b] * polynomial2[a]);\n            end\n        end\n\n        for (int k = 0; k < 4; k++) begin\n    if (temp_result[k] < 0) begin\n        temp_result[k] = (temp_result[k] % 17 + 17) % 17;\n    end else begin\n        temp_result[k] = temp_result[k] % 17;\n    end\n    // $display(temp_result[k]);\nend\n\n\n    end\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            polynomial_out[0] <= 0;\n            polynomial_out[1] <= 0;\n            polynomial_out[2] <= 0;\n            polynomial_out[3] <= 0;\n        end else if (enable) begin\n            polynomial_out[0] <= temp_result[0];\n            polynomial_out[1] <= temp_result[1];\n            polynomial_out[2] <= temp_result[2];\n            polynomial_out[3] <= temp_result[3];\n            \n        end\n    end\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"KeyGeneration.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule KeyGeneration (\n   \n    input logic signed [31:0] A [3:0][3:0],\n    input logic signed[31:0] e [1:0][3:0],\n    input logic signed [31:0] secret_key [1:0][3:0],\n    output logic signed [31:0] secretkey [1:0][3:0],\n    output logic signed [31:0] result [1:0][3:0],\n    output logic signed [31:0] combined_output [1:0][3:0][3:0],\n    input logic clk,\n    input logic rst_n,\n    input logic key_enable,\n    output logic key_done\n);\n   \n    logic signed[31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] poly_out2 [3:0];\n    logic signed [31:0] poly_out3 [3:0];\n    logic signed [31:0] added [3:0];\n    logic signed [31:0] added1 [3:0];\n    logic key_done_next; // Intermediate signal for delaying key_done\n\n    // Secret key assignment\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            for (int i = 0; i < 2; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    secretkey[i][j] <= 0;\n                end\n            end\n        end else if (key_enable) begin\n            secretkey[0][0] <= secret_key[0][0];\n            secretkey[0][1] <= secret_key[0][1];\n            secretkey[0][2] <= secret_key[0][2];\n            secretkey[0][3] <= secret_key[0][3];\n            secretkey[1][0] <= secret_key[1][0];\n            secretkey[1][1] <= secret_key[1][1];\n            secretkey[1][2] <= secret_key[1][2];\n            secretkey[1][3] <= secret_key[1][3];\n        end\n    end\n\n    // Polynomial matrix multiplications\n    PolynomialMatrixMultiplication poly_mult0 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[0]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out0)\n    );\n    \n    PolynomialMatrixMultiplication poly_mult1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[1]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    PolynomialMatrixMultiplication poly_mult2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[2]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out2)\n    );\n\n    PolynomialMatrixMultiplication poly_mult3 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(key_enable),\n        .polynomial1(A[3]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out3)\n    );\n\n    // Combinational logic for result computation\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            added[i] = 0;\n            added1[i] = 0;\n            result[0][i] = 0;\n            result[1][i] = 0;\n        end\n        if (key_enable) begin\n            for (int i = 0; i < 4; i++) begin\n                added[i] = (poly_out0[i] + poly_out1[i]);\n                added1[i] = (poly_out2[i] + poly_out3[i]);\n                if (added[i] < 0) begin\n                    added[i] = added[i];\n                end else begin\n                    added[i] = (added[i] % 17);\n                end\n\n                if (added1[i] < 0) begin\n                    added1[i] = added1[i];\n                end else begin\n                    added1[i] = (added1[i] % 17);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                result[0][i] = added[i] + e[0][i];\n                result[1][i] = added1[i] + e[1][i];\n                if (result[0][i] < 0) begin\n                    result[0][i] = result[0][i];\n                end else begin\n                    result[0][i] = (result[0][i] % 17);\n                end\n                if (result[1][i] < 0) begin\n                    result[1][i] = result[1][i];\n                end else begin\n                    result[1][i] = (result[1][i] % 17);\n                end\n            end\n        end\n    end\n\n    // Sequential logic for combined_output and key_done\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            for (int i = 0; i < 2; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    for (int k = 0; k < 4; k++) begin\n                        combined_output[i][j][k] <= 0;\n                    end\n                end\n            end\n            key_done <= 0;\n            key_done_next <= 0;\n        end else begin\n            if (key_enable) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        combined_output[0][i][j] <= A[i][j];\n                    end\n                end\n                for (int i = 0; i < 2; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        combined_output[1][i][j] <= result[i][j];\n                    end\n                end\n                key_done_next <= 1; // Set intermediate signal\n            end else begin\n                key_done_next <= 0;\n            end\n            key_done <= key_done_next; // Delay key_done by one cycle\n        end\n    end\n\nendmodule"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"Encrypt.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule Encrypt (\n    input logic clk,\n    input logic rst_n,\n    input logic encryption_enable,\n    input logic [31:0] message,\n    input logic signed [31:0] r [1:0][3:0],\n    input logic signed [31:0] e1 [1:0][3:0],\n    input logic signed [31:0] e2 [3:0],\n    input logic signed [31:0] combined_output [1:0][3:0][3:0],\n    output logic signed [31:0] ciphertext[1:0] [1:0][3:0],\n    output logic encryption_done\n);\n\n    logic signed [31:0] transposed_matrix [3:0][3:0];\n    logic signed [31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] poly_out2 [3:0];\n    logic signed [31:0] poly_out3 [3:0];\n    logic signed [31:0] poly_out4 [3:0];\n    logic signed [31:0] poly_out5 [3:0];\n    logic signed [31:0] added [3:0];\n    logic signed [31:0] added1 [3:0];\n    logic signed [31:0] added2 [3:0];\n    logic signed [3:0] coefficients;\n    logic signed [31:0] coefficients_scaled [3:0];\n    logic signed [31:0] u [1:0][3:0];\n    logic signed [31:0] v [3:0];\n    logic signed [31:0] temp [3:0];\n\n    MatrixTranspose transpose_inst (\n        .matrix_in(combined_output[0]),\n        .matrix_out(transposed_matrix)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[0]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out0)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[1]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[2]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out2)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst3 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(transposed_matrix[3]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out3)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst4 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(combined_output[1][0]),\n        .polynomial2(r[0]),\n        .polynomial_out(poly_out4)\n    );\n\n    PolynomialMatrixMultiplication poly_mult_inst5 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(encryption_enable),\n        .polynomial1(combined_output[1][1]),\n        .polynomial2(r[1]),\n        .polynomial_out(poly_out5)\n    );\n\n    always_ff @(posedge clk ) begin\n        if (!rst_n) begin\n                for (int j = 0; j < 4; j++) begin\n                    coefficients[j] <= 0;\n\n                end\n            \n        end else if (encryption_enable) begin\n            \n            for (int i = 0; i < 4; i++) begin\n                    coefficients[i] <= message[i];\n\n                end\n\n           encryption_done<=1;\n        end\n    end\n\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            added[i] = 0;\n            added1[i] = 0;\n            added2[i] = 0;\n            u[0][i] = 0;\n            u[1][i] = 0;\n        end\n        if (encryption_enable) begin\n            \n            for (int i = 0; i < 4; i++) begin\n                \n                added[i] = (poly_out0[i] + poly_out1[i]);\n                added1[i] = (poly_out2[i] + poly_out3[i]);\n                added2[i] = (poly_out4[i] + poly_out5[i]); \n\n                if (added[i] < 0) begin\n                    added[i] = added[i]; \n                end else begin\n                    added[i] = (added[i] % 17);\n                end\n\n                if (added1[i] < 0) begin\n                    added1[i] = added1[i] ;\n                end else begin\n                    added1[i] = (added1[i] % 17);\n                end\n\n                if (added2[i] < 0) begin\n                    added2[i] = added2[i];\n                end else begin\n                    added2[i] = (added2[i] % 17);\n                end\n               \n            end\n           \n            for (int i = 0; i < 4; i++) begin\n                u[0][i] = added[i] + e1[0][i];\n                u[1][i] = added1[i] + e1[1][i];\n                 if ( u[0][i]  < 0) begin\n                     u[0][i]  = u[0][i] ;\n                end else begin\n                     u[0][i]  = ( u[0][i]  % 17);\n                end\n                if ( u[1][i]  < 0) begin\n                     u[1][i]  = u[1][i] ;\n                end else begin\n                     u[1][i]  = ( u[1][i]  % 17);\n\n                \n            end\n        end\n    end\n    end\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            if (coefficients[i] == 1) begin\n                coefficients_scaled[i] = 9;  // Multiply by qhalf = 9\n            end else begin\n                coefficients_scaled[i] = 0;  \n            end\n        end\n    end\n\n    always_comb begin\n\n        for (int i = 0; i < 4; i++) begin\n            \n            v[i] = (added2[i] + e2[i]) - coefficients_scaled[3-i];\n             if ( v[i] < 0) begin\n                     v[i] = v[i] + 17;\n                end else begin\n                     v[i] = ( v[i] % 17);\n                end\n            \n        end\n        for (int i = 0; i < 2; i++) begin\n            \n            for (int j = 0; j < 4; j++) begin\n                ciphertext[0][i][j] = u[i][j];\n                ciphertext[1][0][j] = v[j];\n            end\n            \n        end\n                \n\n    end\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"Decrypt.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule Decrypt (\n    input logic clk,\n    input logic rst_n,\n    input logic decryption_enable,\n    input logic signed [31:0] secret_key [1:0][3:0],\n    input logic signed [31:0] ciphertext[1:0][1:0][3:0],\n    output logic signed [3:0] m_b, \n    output logic decryption_done,\n    output logic [31:0] decimal_value    \n);\n    parameter int Q = 17; \n    logic signed [31:0] poly_out0 [3:0];\n    logic signed [31:0] poly_out1 [3:0];\n    logic signed [31:0] temp_m_n [3:0];\n    logic decryption_done_next; // Intermediate signal for delaying decryption_done\n\n    PolynomialMatrixMultiplication poly_mult1 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(decryption_enable),\n        .polynomial1(ciphertext[0][0]),\n        .polynomial2(secret_key[0]),\n        .polynomial_out(poly_out0)\n    );\n\n    PolynomialMatrixMultiplication poly_mult2 (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(decryption_enable),\n        .polynomial1(ciphertext[0][1]),\n        .polynomial2(secret_key[1]),\n        .polynomial_out(poly_out1)\n    );\n\n    always_comb begin\n        for (int i = 0; i < 4; i++) begin\n            temp_m_n[i] = ciphertext[1][0][i] - (poly_out0[i] + poly_out1[i]);\n\n            if (temp_m_n[i] < 0) begin\n                temp_m_n[i] += Q;\n                if (temp_m_n[i] < 0) begin\n                    temp_m_n[i] += Q;\n                end\n            end else begin\n                temp_m_n[i] = temp_m_n[i] % Q;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            if (temp_m_n[i] < 5) begin\n                temp_m_n[i] = 0;\n            end else if (temp_m_n[i] < 14) begin\n                temp_m_n[i] = 9;\n            end else begin\n                temp_m_n[i] = 0;\n            end\n        end\n\n        for (int i = 0; i < 4; i++) begin\n            m_b[i] = (temp_m_n[i] == 9) ? 1 : 0;\n        end\n        \n        decimal_value = (m_b[0] ? 8 : 0) | (m_b[1] ? 4 : 0) | (m_b[2] ? 2 : 0) | (m_b[3] ? 1 : 0);\n        $display(\"decimal_value = %0d\", decimal_value);\n    end\n\n    // Sequential logic for decryption_done\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            decryption_done <= 0;\n            decryption_done_next <= 0;\n        end else begin\n            decryption_done_next <= decryption_enable; // Set when decryption_enable is active\n            decryption_done <= decryption_done_next; // Delay by one cycle\n        end\n    end\n\nendmodule"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.kybertop",
    "name":"kybertop.sv",
    "text":"/* Created By Hamna Mohiuddin @hamnamohi as a Google Summer of Code 2024 Project.*/\n\nmodule kybertop (\n    input logic clk,\n    input logic rst_n,\n    input logic enable,\n    input logic key_enable,\n    input logic encryption_enable,\n    input logic decryption_enable,\n    input logic signed [31:0] data_Req,\n    input logic signed [31:0] addr_Req,\n    input logic wen_Req,\n    output logic key_done,\n    output logic encryption_done,\n    output logic decryption_done,\n    input logic [7:0] bytelane_Req,\n    output logic signed [31:0] data_Resp\n\n);\n\n// logic [31:0] data_Resp;\nlogic signed [31:0] secretkey [1:0][3:0];\nlogic signed [31:0] result [1:0][3:0];\nlogic signed [31:0] public_key [1:0][3:0][3:0];\nlogic signed [31:0] A_reg [3:0][3:0];\nlogic signed [31:0] s_reg [1:0][3:0];\nlogic signed [31:0] e_reg [1:0][3:0];\nlogic signed [31:0] ciphertext[1:0] [1:0][3:0];\nlogic signed [31:0] r [1:0][3:0];\nlogic signed [31:0] e1 [1:0][3:0];\nlogic signed [31:0] e2 [3:0];\nlogic signed [31:0] decimal_value;\nlogic signed [3:0] m_b;\n\n//Key Generation Input Registers\nlogic signed [31:0] A_t000;\nlogic signed [31:0] A_t001;\nlogic signed [31:0] A_t002;\nlogic signed [31:0] A_t003;\nlogic signed [31:0] A_t010;\nlogic signed [31:0] A_t011;\nlogic signed [31:0] A_t012;\nlogic signed [31:0] A_t013;\nlogic signed [31:0] A_t020;\nlogic signed [31:0] A_t021;\nlogic signed [31:0] A_t022;\nlogic signed [31:0] A_t023;\nlogic signed [31:0] A_t030;\nlogic signed [31:0] A_t031;\nlogic signed [31:0] A_t032;\nlogic signed [31:0] A_t033;\n\nlogic signed [31:0] s_00;\nlogic signed [31:0] s_01;\nlogic signed [31:0] s_02;\nlogic signed [31:0] s_03;\nlogic signed [31:0] s_10;\nlogic signed [31:0] s_11;\nlogic signed [31:0] s_12;\nlogic signed [31:0] s_13;\n\nlogic signed [31:0] e_00;\nlogic signed [31:0] e_01;\nlogic signed [31:0] e_02;\nlogic signed [31:0] e_03;\nlogic signed [31:0] e_10;\nlogic signed [31:0] e_11;\nlogic signed [31:0] e_12;\nlogic signed [31:0] e_13;\n\n//Encrypt Input Registers\nlogic signed [31:0] message;\n\nlogic signed [31:0] public_key000;\nlogic signed [31:0] public_key001;\nlogic signed [31:0] public_key002;\nlogic signed [31:0] public_key003;\nlogic signed [31:0] public_key010;\nlogic signed [31:0] public_key011;\nlogic signed [31:0] public_key012;\nlogic signed [31:0] public_key013;\nlogic signed [31:0] public_key020;\nlogic signed [31:0] public_key021;\nlogic signed [31:0] public_key022;\nlogic signed [31:0] public_key023;\nlogic signed [31:0] public_key030;\nlogic signed [31:0] public_key031;\nlogic signed [31:0] public_key032;\nlogic signed [31:0] public_key033;\nlogic signed [31:0] public_key100;\nlogic signed [31:0] public_key101;\nlogic signed [31:0] public_key102;\nlogic signed [31:0] public_key103;\nlogic signed [31:0] public_key110;\nlogic signed [31:0] public_key111;\nlogic signed [31:0] public_key112;\nlogic signed [31:0] public_key113;\n\nlogic signed [31:0] r_00;\nlogic signed [31:0] r_01;\nlogic signed [31:0] r_02;\nlogic signed [31:0] r_03;\nlogic signed [31:0] r_10;\nlogic signed [31:0] r_11;\nlogic signed [31:0] r_12;\nlogic signed [31:0] r_13;\n\nlogic signed [31:0] e1_00;\nlogic signed [31:0] e1_01;\nlogic signed [31:0] e1_02;\nlogic signed [31:0] e1_03;\nlogic signed [31:0] e1_10;\nlogic signed [31:0] e1_11;\nlogic signed [31:0] e1_12;\nlogic signed [31:0] e1_13;\n\nlogic signed [31:0] e2_0;\nlogic signed [31:0] e2_1;\nlogic signed [31:0] e2_2;\nlogic signed [31:0] e2_3;\n\n//Decryption Input Registers\nlogic signed [31:0] ciphertext000;\nlogic signed [31:0] ciphertext001;\nlogic signed [31:0] ciphertext002;\nlogic signed [31:0] ciphertext003;\nlogic signed [31:0] ciphertext010;\nlogic signed [31:0] ciphertext011;\nlogic signed [31:0] ciphertext012;\nlogic signed [31:0] ciphertext013;\nlogic signed [31:0] ciphertext100;\nlogic signed [31:0] ciphertext101;\nlogic signed [31:0] ciphertext102;\nlogic signed [31:0] ciphertext103;\n\n\nKeyGeneration keygen (\n    .clk(clk),\n    .rst_n(rst_n),\n    .key_enable(key_enable),\n    .A(A_reg),\n    .secret_key(s_reg),\n    .e(e_reg),\n    .secretkey(secretkey),\n    .result(result),\n    .key_done(key_done),\n    .combined_output(public_key)\n);\nEncrypt encryption (\n    .clk(clk),\n    .rst_n(rst_n),\n    .encryption_enable(encryption_enable),\n    .message(message),\n    .combined_output(public_key),\n    .r(r),\n    .e1(e1),\n    .e2(e2),\n    .encryption_done(encryption_done),\n    .ciphertext(ciphertext)\n);\nDecrypt decryption (\n    .clk(clk),\n    .rst_n(rst_n),\n    .decryption_enable(decryption_enable),\n    .ciphertext(ciphertext),\n    .secret_key(secretkey),\n    .m_b(m_b),\n    .decryption_done(decryption_done),\n    .decimal_value(decimal_value)\n\n);\n\n\n    always_ff @(posedge clk ) begin\n        if (!rst_n) begin\n            for (int i = 0; i < 2; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    secretkey[i][j] <= 32'b0;\n                    result[i][j] <= 32'b0;\n                    s_reg[i][j] <= 32'b0;\n                    e_reg[i][j] <= 32'b0;\n                    r[i][j] <= 32'b0;\n                    e1[i][j] <= 32'b0;\n                    ciphertext[0][i][j] <= 32'b0;\n                    ciphertext[1][i][j] <= 32'b0;\n                end\n            end\n\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    A_reg[i][j] <= 32'b0;\n                    public_key[0][i][j] <= 32'b0;\n                    public_key[1][i][j] <= 32'b0;\n                end\n            end\n\n            for (int i = 0; i < 4; i++) begin\n                e2[i] <= 32'b0;\n            end\n\n            \n            \n            data_Resp <= 32'b0;\n            // decimal_value <= 3'b0;\n\n        // Resetting arrays and matrices to zero\n        \n            A_t000 <= 32'b0;\n            A_t001 <= 32'b0;\n            A_t002 <= 32'b0;\n            A_t003 <= 32'b0;\n            A_t010 <= 32'b0;\n            A_t011 <= 32'b0;\n            A_t012 <= 32'b0;\n            A_t013 <= 32'b0;\n            A_t020 <= 32'b0;\n            A_t021 <= 32'b0;\n            A_t022 <= 32'b0;\n            A_t023 <= 32'b0;\n            A_t030 <= 32'b0;\n            A_t031 <= 32'b0;\n            A_t032 <= 32'b0;\n            A_t033 <= 32'b0;\n\n            s_00 <= 32'b0;\n            s_01 <= 32'b0;\n            s_02 <= 32'b0;\n            s_03 <= 32'b0;\n            s_10 <= 32'b0;\n            s_11 <= 32'b0;\n            s_12 <= 32'b0;\n            s_13 <= 32'b0;\n\n            e_00 <= 32'b0;\n            e_01 <= 32'b0;\n            e_02 <= 32'b0;\n            e_03 <= 32'b0;\n            e_10 <= 32'b0;\n            e_11 <= 32'b0;\n            e_12 <= 32'b0;\n            e_13 <= 32'b0;\n\n            // Reset Encryption Registers\n            public_key000 <= 32'b0;\n            public_key001 <= 32'b0;\n            public_key002 <= 32'b0;\n            public_key003 <= 32'b0;\n            public_key010 <= 32'b0;\n            public_key011 <= 32'b0;\n            public_key012 <= 32'b0;\n            public_key013 <= 32'b0;\n            public_key020 <= 32'b0;\n            public_key021 <= 32'b0;\n            public_key022 <= 32'b0;\n            public_key023 <= 32'b0;\n            public_key030 <= 32'b0;\n            public_key031 <= 32'b0;\n            public_key032 <= 32'b0;\n            public_key033 <= 32'b0;\n            public_key100 <= 32'b0;\n            public_key101 <= 32'b0;\n            public_key102 <= 32'b0;\n            public_key103 <= 32'b0;\n            public_key110 <= 32'b0;\n            public_key111 <= 32'b0;\n            public_key112 <= 32'b0;\n            public_key113 <= 32'b0;\n\n            r_00 <= 32'b0;\n            r_01 <= 32'b0;\n            r_02 <= 32'b0;\n            r_03 <= 32'b0;\n            r_10 <= 32'b0;\n            r_11 <= 32'b0;\n            r_12 <= 32'b0;\n            r_13 <= 32'b0;\n\n            e1_00 <= 32'b0;\n            e1_01 <= 32'b0;\n            e1_02 <= 32'b0;\n            e1_03 <= 32'b0;\n            e1_10 <= 32'b0;\n            e1_11 <= 32'b0;\n            e1_12 <= 32'b0;\n            e1_13 <= 32'b0;\n\n            e2_0 <= 32'b0;\n            e2_1 <= 32'b0;\n            e2_2 <= 32'b0;\n            e2_3 <= 32'b0;\n\n            // Reset Decryption Registers\n            ciphertext000 <= 32'b0;\n            ciphertext001 <= 32'b0;\n            ciphertext002 <= 32'b0;\n            ciphertext003 <= 32'b0;\n            ciphertext010 <= 32'b0;\n            ciphertext011 <= 32'b0;\n            ciphertext012 <= 32'b0;\n            ciphertext013 <= 32'b0;\n            ciphertext100 <= 32'b0;\n            ciphertext101 <= 32'b0;\n            ciphertext102 <= 32'b0;\n            ciphertext103 <= 32'b0;\n\n           \n\n        end else if (enable) begin \n            //keygen\n            if (wen_Req == 1'b1  )begin  \n                data_Resp <= 1;\n                $display(\"checking\");\n            if ( addr_Req == 'h40007000  )begin\n                A_t000 <= data_Req;\n\n            end else if (addr_Req == 'h40007004  )begin\n                A_t001 <= data_Req;\n            end\n            else if (addr_Req == 'h40007008 )begin\n                A_t002 <= data_Req;\n            end\n            else if (addr_Req == 'h40007012 )begin\n                A_t003 <= data_Req;\n            end\n            else if (addr_Req == 'h40007016 )begin\n                A_t010 <= data_Req;\n            end\n            else if (addr_Req == 'h40007020 )begin\n                A_t011 <= data_Req;\n            end\n            else if (addr_Req == 'h40007024 )begin\n                A_t012 <= data_Req;\n            end\n            else if (addr_Req == 'h40007028 )begin\n                A_t013 <= data_Req;\n            end\n            else if (addr_Req == 'h40007032 )begin\n                A_t020 <= data_Req;\n            end\n            else if (addr_Req == 'h40007036 )begin\n                A_t021 <= data_Req;\n            end\n            else if (addr_Req == 'h40007040 )begin\n                A_t022 <= data_Req;\n            end\n            else if (addr_Req == 'h40007044 )begin\n                A_t023 <= data_Req;\n            end\n            else if (addr_Req == 'h40007048 )begin\n                A_t030 <= data_Req;\n            end\n            else if (addr_Req == 'h40007052 )begin\n                A_t031 <= data_Req;\n            end\n            else if (addr_Req == 'h40007056 )begin\n                A_t032 <= data_Req;\n            end\n            else if (addr_Req == 'h40007060 )begin\n                A_t033 <= data_Req;\n            end\n            else if (addr_Req == 'h40007064 )begin\n                s_00 <= data_Req;\n            end\n            else if (addr_Req == 'h40007068 )begin\n                s_01 <= data_Req;\n            end\n            else if (addr_Req == 'h40007072 )begin\n                s_02 <= data_Req;\n            end\n            else if (addr_Req == 'h40007076 )begin\n                s_03 <= data_Req;\n            end\n            else if (addr_Req == 'h40007080 )begin\n                s_10 <= data_Req;\n            end\n            else if (addr_Req == 'h40007084 )begin\n                s_11 <= data_Req;\n            end\n            else if (addr_Req == 'h40007088 )begin\n                s_12 <= data_Req;\n            end\n            else if (addr_Req == 'h40007092 )begin\n                s_13 <= data_Req;\n            end\n            else if (addr_Req == 'h40007096 )begin\n                e_00 <= data_Req;\n            end\n            else if (addr_Req == 'h40007100 )begin\n                e_01 <= data_Req;\n            end\n            else if (addr_Req == 'h40007104 )begin\n                e_02 <= data_Req;\n            end\n            else if (addr_Req == 'h40007108 )begin\n                e_03 <= data_Req;\n            end\n            else if (addr_Req == 'h40007112 )begin\n                e_10 <= data_Req;\n            end\n            else if (addr_Req == 'h40007116 )begin\n                e_11 <= data_Req;\n            end\n            else if (addr_Req == 'h40007120 )begin\n                e_12 <= data_Req;\n            end\n            else if (addr_Req == 'h40007124 )begin\n                e_13 <= data_Req;\n            end\n            else if (addr_Req == 'h40007128 )begin //encrypt\n                message <= data_Req;\n            end\n            else if (addr_Req == 'h40007132 )begin\n                public_key000 <= data_Req;\n            end\n            else if (addr_Req == 'h40007136 )begin\n                public_key001 <= data_Req;\n            end\n            else if (addr_Req == 'h40007140 )begin\n                public_key002 <= data_Req;\n            end\n            else if (addr_Req == 'h40007144 )begin\n                public_key003 <= data_Req;\n            end\n            else if (addr_Req == 'h40007148 )begin\n                public_key010 <= data_Req;\n            end\n            else if (addr_Req == 'h40007152 )begin\n                public_key011 <= data_Req;\n            end\n            else if (addr_Req == 'h40007156 )begin\n                public_key012 <= data_Req;\n            end\n            else if (addr_Req == 'h40007160 )begin\n                public_key013 <= data_Req;\n            end\n            else if (addr_Req == 'h40007164 )begin\n                public_key020 <= data_Req;\n            end\n            else if (addr_Req == 'h40007168 )begin\n                public_key021 <= data_Req;\n            end\n            else if (addr_Req == 'h40007172 )begin\n                public_key022 <= data_Req;\n            end\n            else if (addr_Req == 'h40007176 )begin\n                public_key023 <= data_Req;\n            end\n            else if (addr_Req == 'h40007180 )begin\n                public_key030 <= data_Req;\n            end\n            else if (addr_Req == 'h40007184 )begin\n                public_key031 <= data_Req;\n            end\n            else if (addr_Req == 'h40007188 )begin\n                public_key032 <= data_Req;\n            end\n            else if (addr_Req == 'h40007192 )begin\n                public_key033 <= data_Req;\n            end\n            else if (addr_Req == 'h40007196 )begin\n                public_key100 <= data_Req;\n            end\n            else if (addr_Req == 'h40007200 )begin\n                public_key101 <= data_Req;\n            end\n            else if (addr_Req == 'h40007204 )begin\n                public_key102 <= data_Req;\n            end\n            else if (addr_Req == 'h40007208 )begin\n                public_key103 <= data_Req;\n            end\n            else if (addr_Req == 'h40007212 )begin\n                public_key110 <= data_Req;\n            end\n            else if (addr_Req == 'h40007216 )begin\n                public_key111 <= data_Req;\n            end\n            else if (addr_Req == 'h40007220 )begin\n                public_key112 <= data_Req;\n            end\n            else if (addr_Req == 'h40007224 )begin\n                public_key113 <= data_Req;\n            end\n            else if (addr_Req == 'h40007228 )begin\n                r_00 <= data_Req;\n            end\n            else if (addr_Req == 'h40007232 )begin\n                r_01 <= data_Req;\n            end\n            else if (addr_Req == 'h40007236 )begin\n                r_02 <= data_Req;\n            end\n            else if (addr_Req == 'h40007240 )begin\n                r_03 <= data_Req;\n            end\n            else if (addr_Req == 'h40007244 )begin\n                r_10 <= data_Req;\n            end\n            else if (addr_Req == 'h40007248 )begin\n                r_11 <= data_Req;\n            end\n            else if (addr_Req == 'h40007252 )begin\n                r_12 <= data_Req;\n            end\n            else if (addr_Req == 'h40007256 )begin\n                r_13 <= data_Req;\n            end\n            else if (addr_Req == 'h40007260 )begin\n                e1_00 <= data_Req;\n            end\n            else if (addr_Req == 'h40007264 )begin\n                e1_01 <= data_Req;\n            end\n            else if (addr_Req == 'h40007268 )begin\n                e1_02 <= data_Req;\n            end\n            else if (addr_Req == 'h40007272 )begin\n                e1_03 <= data_Req;\n            end\n            else if (addr_Req == 'h40007276 )begin\n                e1_10 <= data_Req;\n            end\n            else if (addr_Req == 'h40007280 )begin\n                e1_11 <= data_Req;\n            end\n            else if (addr_Req == 'h40007284 )begin\n                e1_12 <= data_Req;\n            end\n            else if (addr_Req == 'h40007288 )begin\n                e1_13 <= data_Req;\n            end\n            else if (addr_Req == 'h40007292 )begin\n                e2_0 <= data_Req;\n            end\n            else if (addr_Req == 'h40007296 )begin\n                e2_1 <= data_Req;\n            end\n            else if (addr_Req == 'h40007300 )begin\n                e2_2 <= data_Req;\n            end\n            else if (addr_Req == 'h40007304 )begin\n                e2_3 <= data_Req;\n            end\n            else if (addr_Req == 'h40007308)begin\n                ciphertext000 <= data_Req;\n            end\n            else if (addr_Req == 'h40007312 )begin\n                ciphertext001 <= data_Req;\n            end\n            else if (addr_Req == 'h40007316 )begin\n                ciphertext002 <= data_Req;\n            end\n            else if (addr_Req == 'h40007320 )begin\n                ciphertext003 <= data_Req;\n            end\n            else if (addr_Req == 'h40007324 )begin\n                ciphertext010 <= data_Req;\n            end\n            else if (addr_Req == 'h40007328 )begin\n                ciphertext011 <= data_Req;\n            end\n            else if (addr_Req == 'h40007332 )begin\n                ciphertext012 <= data_Req;\n            end\n            else if (addr_Req == 'h40007336 )begin\n                ciphertext013 <= data_Req;\n            end\n            else if (addr_Req == 'h40007340 )begin\n                ciphertext100 <= data_Req;\n            end\n            else if (addr_Req == 'h40007344 )begin\n                ciphertext101 <= data_Req;\n            end\n            else if (addr_Req == 'h40007348 )begin\n                ciphertext102 <= data_Req;\n            end\n            else if (addr_Req == 'h40007352 )begin\n                ciphertext103 <= data_Req;\n            end\n            else if (addr_Req == 'h40007356 )begin\n\n                //key generation inputs\n                A_reg[0][0] <= A_t000;\n                A_reg[0][1] <= A_t001;\n                A_reg[0][2] <= A_t002;\n                A_reg[0][3] <= A_t003;\n                \n                A_reg[1][0] <= A_t010;\n                A_reg[1][1] <= A_t011;\n                A_reg[1][2] <= A_t012;\n                A_reg[1][3] <= A_t013;\n                \n                A_reg[2][0] <= A_t020;\n                A_reg[2][1] <= A_t021;\n                A_reg[2][2] <= A_t022;\n                A_reg[2][3] <= A_t023;\n                \n                A_reg[3][0] <= A_t030;\n                A_reg[3][1] <= A_t031;\n                A_reg[3][2] <= A_t032;\n                A_reg[3][3] <= A_t033;\n\n                s_reg[0][0] <= s_00;\n                s_reg[0][1] <= s_01;\n                s_reg[0][2] <= s_02;\n                s_reg[0][3] <= s_03;\n                s_reg[1][0] <= s_10;\n                s_reg[1][1] <= s_11;\n                s_reg[1][2] <= s_12;\n                s_reg[1][3] <= s_13;\n\n                e_reg[0][0] <= e_00;\n                e_reg[0][1] <= e_01;\n                e_reg[0][2] <= e_02;\n                e_reg[0][3] <= e_03;\n                e_reg[1][0] <= e_10;\n                e_reg[1][1] <= e_11;\n                e_reg[1][2] <= e_12;\n                e_reg[1][3] <= e_13;\n\n                //key generation outputs to output registers\n                public_key000 <= public_key[0][0][0];\n                public_key001 <= public_key[0][0][1];\n                public_key002 <= public_key[0][0][2];\n                public_key003 <= public_key[0][0][3];\n                public_key010 <= public_key[0][1][0];\n                public_key011 <= public_key[0][1][1];\n                public_key012 <= public_key[0][1][2];\n                public_key013 <= public_key[0][1][3];\n                public_key020 <= public_key[0][2][0];\n                public_key021 <= public_key[0][2][1];\n                public_key022 <= public_key[0][2][2];\n                public_key023 <= public_key[0][2][3];\n                public_key030 <= public_key[0][3][0];\n                public_key031 <= public_key[0][3][1];\n                public_key032 <= public_key[0][3][2];\n                public_key033 <= public_key[0][3][3];\n                public_key100 <= public_key[1][0][0];\n                public_key101 <= public_key[1][0][1];\n                public_key102 <= public_key[1][0][2];\n                public_key103 <= public_key[1][0][3];\n                public_key110 <= public_key[1][1][0];\n                public_key111 <= public_key[1][1][1];\n                public_key112 <= public_key[1][1][2];\n                public_key113 <= public_key[1][1][3];\n\n               // s_reg <= secretkey;\n            end\n            else if (addr_Req == 'h40007360 )begin\n                //encrypt inputs\n               // message <= data_Req;\n                public_key[0][0][0] <= public_key000;\n                public_key[0][0][1] <= public_key001;\n                public_key[0][0][2] <= public_key002;\n                public_key[0][0][3] <= public_key003;\n                public_key[0][1][0] <= public_key010;\n                public_key[0][1][1] <= public_key011;\n                public_key[0][1][2] <= public_key012;\n                public_key[0][1][3] <= public_key013;\n                public_key[0][2][0] <= public_key020;\n                public_key[0][2][1] <= public_key021;\n                public_key[0][2][2] <= public_key022;\n                public_key[0][2][3] <= public_key023;\n                public_key[0][3][0] <= public_key030;\n                public_key[0][3][1] <= public_key031;\n                public_key[0][3][2] <= public_key032;\n                public_key[0][3][3] <= public_key033;\n                public_key[1][0][0] <= public_key100;\n                public_key[1][0][1] <= public_key101;\n                public_key[1][0][2] <= public_key102;\n                public_key[1][0][3] <= public_key103;\n                public_key[1][1][0] <= public_key110;\n                public_key[1][1][1] <= public_key111;\n                public_key[1][1][2] <= public_key112;\n                public_key[1][1][3] <= public_key113;\n\n                r[0][0] <= r_00;\n                r[0][1] <= r_01;\n                r[0][2] <= r_02;\n                r[0][3] <= r_03;\n                r[1][0] <= r_10;\n                r[1][1] <= r_11;\n                r[1][2] <= r_12;\n                r[1][3] <= r_13;\n\n                e1[0][0] <= e1_00;\n                e1[0][1] <= e1_01;\n                e1[0][2] <= e1_02;\n                e1[0][3] <= e1_03;\n                e1[1][0] <= e1_10;\n                e1[1][1] <= e1_11;\n                e1[1][2] <= e1_12;\n                e1[1][3] <= e1_13;\n\n                e2[0] <= e2_0;\n                e2[1] <= e2_1;\n                e2[2] <= e2_2;\n                e2[3] <= e2_3;\n\n                // output\n                ciphertext000 <= ciphertext[0][0][0];\n                ciphertext001 <= ciphertext[0][0][1];\n                ciphertext002 <= ciphertext[0][0][2];\n                ciphertext003 <= ciphertext[0][0][3];\n                ciphertext010 <= ciphertext[0][1][0];\n                ciphertext011 <= ciphertext[0][1][1];\n                ciphertext012 <= ciphertext[0][1][2];\n                ciphertext013 <= ciphertext[0][1][3];\n                ciphertext100 <= ciphertext[1][0][0];\n                ciphertext101 <= ciphertext[1][0][1];\n                ciphertext102 <= ciphertext[1][0][2];\n                ciphertext103 <= ciphertext[1][0][3];\n\n            end\n            else if (addr_Req == 'h40007364 )begin\n                //decrypt\n                ciphertext[0][0][0] <= ciphertext000;\n                ciphertext[0][0][1] <= ciphertext001;\n                ciphertext[0][0][2] <= ciphertext002;\n                ciphertext[0][0][3] <= ciphertext003;\n                ciphertext[0][1][0] <= ciphertext010;\n                ciphertext[0][1][1] <= ciphertext011;\n                ciphertext[0][1][2] <= ciphertext012;\n                ciphertext[0][1][3] <= ciphertext013;\n                ciphertext[1][0][0] <= ciphertext100;\n                ciphertext[1][0][1] <= ciphertext101;\n                ciphertext[1][0][2] <= ciphertext102;\n                ciphertext[1][0][3] <= ciphertext103;\n\n                secretkey <= s_reg;\n                //output\n               // message <= decimal_value;\n            end\n            end \n            else if (wen_Req == 1'b0  ) begin \n                if (addr_Req == 'h40007000) begin \n                    data_Resp <= public_key000;\n                end\n                else if (addr_Req == 'h40007004) begin \n                    data_Resp <= public_key001;\n                end\n                else if (addr_Req == 'h40007008) begin \n                    data_Resp <= public_key002;\n                end\n                else if (addr_Req == 'h40007012) begin \n                    data_Resp <= public_key003;\n                end\n                else if (addr_Req == 'h40007016) begin \n                    data_Resp <= public_key010;\n                end\n                else if (addr_Req == 'h40007020) begin \n                    data_Resp <= public_key011;\n                end\n                else if (addr_Req == 'h40007024) begin \n                    data_Resp <= public_key012;\n                end\n                else if (addr_Req == 'h40007028) begin \n                    data_Resp <= public_key013;\n                end\n                else if (addr_Req == 'h40007032) begin \n                    data_Resp <= public_key020;\n                end\n                else if (addr_Req == 'h40007036) begin \n                    data_Resp <= public_key021;\n                end\n                else if (addr_Req == 'h40007040) begin \n                    data_Resp <= public_key022;\n                end\n                else if (addr_Req == 'h40007044) begin \n                    data_Resp <= public_key023;\n                end\n                else if (addr_Req == 'h40007048) begin \n                    data_Resp <= public_key030;\n                end\n                else if (addr_Req == 'h40007052) begin \n                    data_Resp <= public_key031;\n                end\n                else if (addr_Req == 'h40007056) begin \n                    data_Resp <= public_key032;\n                end\n                else if (addr_Req == 'h40007060) begin \n                    data_Resp <= public_key033;\n                end\n                else if (addr_Req == 'h40007064) begin \n                    data_Resp <= public_key100;\n                end\n                else if (addr_Req == 'h40007068) begin \n                    data_Resp <= public_key101;\n                end\n                else if (addr_Req == 'h40007072) begin \n                    data_Resp <= public_key102;\n                end\n                else if (addr_Req == 'h40007076) begin \n                    data_Resp <= public_key103;\n                end\n                else if (addr_Req == 'h40007080) begin \n                    data_Resp <= public_key110;\n                end\n                else if (addr_Req == 'h40007084) begin \n                    data_Resp <= public_key111;\n                end\n                else if (addr_Req == 'h40007088) begin \n                    data_Resp <= public_key112;\n                end\n                else if (addr_Req == 'h40007092) begin \n                    data_Resp <= public_key113;\n                end\n                else if (addr_Req == 'h40007096) begin \n                    data_Resp <= ciphertext000;\n                end\n                else if (addr_Req == 'h40007100) begin \n                    data_Resp <= ciphertext001;\n                end\n                else if (addr_Req == 'h40007104) begin \n                    data_Resp <= ciphertext002;\n                end\n                else if (addr_Req == 'h40007108) begin \n                    data_Resp <= ciphertext003;\n                end\n                else if (addr_Req == 'h40007112) begin \n                    data_Resp <= ciphertext010;\n                end\n                else if (addr_Req == 'h40007116) begin \n                    data_Resp <= ciphertext011;\n                end\n                else if (addr_Req == 'h40007120) begin \n                    data_Resp <= ciphertext012;\n                end\n                else if (addr_Req == 'h40007124) begin \n                    data_Resp <= ciphertext013;\n                end\n                else if (addr_Req == 'h40007128) begin \n                    data_Resp <= ciphertext100;\n                end\n                else if (addr_Req == 'h40007132) begin \n                    data_Resp <= ciphertext101;\n                end\n                else if (addr_Req == 'h40007136) begin \n                    data_Resp <= ciphertext102;\n                end\n                else if (addr_Req == 'h40007140) begin \n                    data_Resp <= ciphertext103;\n                end\n                else if (addr_Req == 'h40007144) begin \n                    data_Resp <= message;\n                end\n                \n            end\n\n        end\n    end\n\nendmodule\n"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|WishboneDevice>io_wbSlaveTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|WishboneDevice>io_wbMasterReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|WishboneHost>io_wbSlaveReceiver_ready"
  },
  {
    "class":"firrtl.transforms.DontTouchAnnotation",
    "target":"~Top|WishboneHost>io_wbMasterTransmitter_ready"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"/home/mhussain/Desktop/nucleusrv/out/main.c"
  },
  {
    "class":"firrtl.transforms.CombinationalPath",
    "sink":"~Top|Top>io_rvfi_valid_0",
    "sources":[
      "~Top|Top>clock"
    ]
  }
]